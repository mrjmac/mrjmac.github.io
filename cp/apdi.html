 
<h1 id="apple-division">Apple Division</h1>
<p><a href="https://github.com/mrjmac/competitive-programming/blob/main/CSES/appleDivision.java">GitHub link</a></p>
<p><a href="https://github.com/mrjmac/competitive-programming/blob/main/CSES/appleDivisionBackTrack.cpp">GitHub link (C++)</a></p>
<p>This is the fifteenth problem in the CSES problem set.</p>
<p>The problem goes like this: There are n apples with known weights. Your task is to divide the apples into two groups so that the difference between the weights of the groups is minimal and output the minimum difference between the weights of the two groups.</p>
<p>This problem seems a lot harder than it actually is. Thankfully, the maximum value of n for this problem is 20. This means that we can efficiently brute force all possible combinations of apples and still stay under the time limit. The key to efficiently brute forcing all combinations of a series of values is to use recursive backtracking. In this case, our base case will add the difference between two sums to an arraylist. Our first recursive call will add the current number to the first sum. The second recursive call will add the current number to the second sum. Once our recursive function is done running, we need to find the minimum value in our arraylist and we&#39;ve solved the problem. Here&#39;s the code for this recursive function in this problem</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> solve(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-keyword">long</span> sum1, <span class="hljs-keyword">long</span> sum2)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == n)
    {
        ans.add(Math.abs(sum1 - sum2));
    }
    <span class="hljs-keyword">else</span>
    {
        solve(<span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>, sum1 + nums[<span class="hljs-keyword">index</span>], sum2);
        solve(<span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>, sum1, sum2 + nums[<span class="hljs-keyword">index</span>]);
    }
}
</code></pre><p>Here&#39;s the driver code for this problem:</p>
<pre><code><span class="hljs-built_in"></span>for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
{
    nums[i] = Integer.<span class="hljs-built_in">parseInt</span>(st.nextToken());
}

solve(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

Long <span class="hljs-built_in">min</span> = Long.MAX_VALUE;
<span class="hljs-built_in">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); i++)
{
    <span class="hljs-built_in">if</span> (ans.<span class="hljs-built_in">get</span>(i) &lt; <span class="hljs-built_in">min</span>)
    {
        <span class="hljs-built_in">min</span> = ans.<span class="hljs-built_in">get</span>(i);
    }
}

pw.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">min</span>);
</code></pre><p>Entry written on 8/10/2022</p>
