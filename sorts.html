<style type="text/css">body{line-height:1.6;font-size:18px;color:#444;}h1,h2,h3{line-height:1.2}code{line-height:normal;font-size:13px;color:normal}</style>
<h1 id="sorts">Sorts</h1>
<p>This page is filled with details and code on all <em>sorts</em> of sorting algorithms, some practical, some not so much.</p>
<h2 id="-dropsort-https-github-com-mrjmac-sorts-blob-main-dropsort-java-"><a href="https://github.com/mrjmac/sorts/blob/main/dropsort.java">dropsort</a></h2>
<ul>
<li>The idea behind this is incredibly simple and produces always runs in O(n). However, this is probably the most impractical sort on the list.</li>
<li>This sort loops through an array filled with numbers starting at Array[i].</li>
<li>If Array[i] is less than Array[i - 1], Array[i] is removed from the Array.</li>
<li>This is considered a lossy sort, like how JPEG compression is considered a method of lossy compression.</li>
<li>The world would be a better place if more government agencies and financial institutions used this to sort their databases.</li>
<li>The main code loop: </li>
<li><pre><code><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
<span class="hljs-built_in">while</span> (i &lt; numbers.<span class="hljs-built_in">size</span>())
{
    <span class="hljs-built_in">if</span> (numbers.<span class="hljs-built_in">get</span>(i) &lt; numbers.<span class="hljs-built_in">get</span>(i - <span class="hljs-number">1</span>))
    {
        numbers.<span class="hljs-built_in">remove</span>(i);

    }
    <span class="hljs-built_in">else</span>
    {
        i++;
    }
}
</code></pre></li>
</ul>
<h2 id="-sleepsort-https-github-com-mrjmac-sorts-blob-main-sleepsort-py-"><a href="https://github.com/mrjmac/sorts/blob/main/sleepsort.py">sleepsort</a></h2>
<ul>
<li>This is the most impractical sort on the list.</li>
<li>This sort creates an thread for each number in the array and calls sleeps for the value of the number. Once it wakes up, it prints the number.</li>
<li>In order to make this work on negative numbers, all negatives values sleep for 1/the absolute value of the number. This gives them a significantly lower time spent sleeping than positive numbers, which makes sense as they are lower. As a sideffect of this, this sort will not work on any decimals.</li>
<li>This sort was written in Python as I prefer how threads function in Python.</li>
<li>Due to the time that it takes for Python to create a thread, this sort can be imperfect at times.</li>
<li>I am not going to attempt to find or justify the time complexity for this sort.</li>
<li>The main code loop: </li>
<li><code>for item in nums :
 x = Thread(target=wait, args=(item,)).start()</code></li>
</ul>
<h2 id="-selectionsort-https-github-com-mrjmac-sorts-blob-main-selectionsort-java-"><a href="https://github.com/mrjmac/sorts/blob/main/selectionsort.java">selectionsort</a></h2>
<ul>
<li>Pretty simple sort but not really ever applicable in every day code.</li>
<li>Repeatedly goes through the unsorted section of the array and finds the smallest element.</li>
<li>Once the smallest element is found, it&#39;s moved to the beginning of the array.</li>
<li>Probably the most intuitive sort.</li>
<li>O(n^2) in all cases as there are two for loops.</li>
<li>The main code loop:</li>
<li><pre><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)
{
    <span class="hljs-comment">//assume that current item is lowest</span>
    <span class="hljs-built_in">int</span> minInd = i;
    <span class="hljs-comment">//verify this information</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">size</span>(); j++)
    {
        <span class="hljs-comment">//set the real min index if we have to</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sort</span>.<span class="hljs-built_in">get</span>(minInd) &gt; <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">get</span>(j))
        {
            minInd = j;
        }
    }
    <span class="hljs-comment">//swap the current item with the lowest</span>
    <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">set</span>(minInd, <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">set</span>(i, <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">get</span>(minInd)));
}
</code></pre></li>
</ul>
<h2 id="-bubblesort-https-github-com-mrjmac-sorts-blob-main-bubblesort-java-"><a href="https://github.com/mrjmac/sorts/blob/main/bubblesort.java">bubblesort</a></h2>
<ul>
<li>Pretty simple overall.</li>
<li>Starts at the first value in the array and compares it to the second value. If the first value is bigger than the second, they are swapped. This process continues until the end of the array is reached.</li>
<li>Once the end of the array is reached, the process is started again. However, since we know that the last value is the biggest, we only sort until Array.length - 1.</li>
<li>This process is continued with the search going one spot less until all numbers are in the correct position.</li>
<li>As there are two for loops, the time complexity here on the average and worst cases are O(n^2). However, if code is written to terminate the process once the Array is sorted, this method is O(n) on it&#39;s best case.</li>
<li>The main code loop:</li>
<li><pre><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> - i; n++)
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sort</span>.<span class="hljs-built_in">get</span>(n) &gt; <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">get</span>(n+<span class="hljs-number">1</span>))
        {
            <span class="hljs-comment">//swap nums</span>
            <span class="hljs-built_in">sort</span> = swap(<span class="hljs-built_in">sort</span>, n);
        }
    }
}
</code></pre></li>
</ul>
<h2 id="-insertionsort-https-github-com-mrjmac-sorts-blob-main-insertionsort-java-"><a href="https://github.com/mrjmac/sorts/blob/main/insertionsort.java">insertionsort</a></h2>
<ul>
<li>Another pretty simple sort, extremely similar to bubble.</li>
<li>Instead of moving the biggest element to the back, it moves the smallest element to the front.</li>
<li>Same time complexity as bubble.</li>
<li>The main code loop:</li>
<li><pre><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">size</span>(); i++)
{
    <span class="hljs-built_in">int</span> curr = <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">get</span>(i);
    <span class="hljs-built_in">int</span> idx = i - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (idx &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">get</span>(idx) &gt; curr)
    {
        <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">set</span>(idx + <span class="hljs-number">1</span>, <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">get</span>(idx));
        idx -= <span class="hljs-number">1</span>;
    }
    <span class="hljs-built_in">sort</span>.<span class="hljs-built_in">set</span>(idx + <span class="hljs-number">1</span>, curr);
}
</code></pre></li>
</ul>
<h2 id="-mergesort-https-github-com-mrjmac-sorts-blob-main-mergesort-java-"><a href="https://github.com/mrjmac/sorts/blob/main/mergesort.java">mergesort</a></h2>
<ul>
<li>While it can be done without recursion, this is much more simple to implement recursively.</li>
<li>Can be hard to grasp at first, but pretty simple once you think about it a bit.</li>
<li>Splits the array into two evenly sized arrays repeatedly until the size of the size of the array is one. Once it is, we begin to merge the arrays together. The code for that can be seen here:</li>
<li><pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; recursiveMergesort(ArrayList&lt;Integer&gt; a)
{
     <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">return</span> a;
    }

    <span class="hljs-built_in">int</span> mid = (a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;

    ArrayList&lt;Integer&gt; one = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    ArrayList&lt;Integer&gt; two = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= mid; i++)
    {
        one.<span class="hljs-built_in">add</span>(a.<span class="hljs-built_in">get</span>(i));
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = mid + <span class="hljs-number">1</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++)
    {
        two.<span class="hljs-built_in">add</span>(a.<span class="hljs-built_in">get</span>(i));
    }

    one = recursiveMergesort(one);
    two = recursiveMergesort(two);

    <span class="hljs-keyword">return</span> merge(one, two);
}
</code></pre></li>
<li>As the compiler gets to higher calls of the recursiveMergesort function in the stack, the arrays are no longer one element big. However, the merge method is written in order to isolate the smallest values in the arrays first. </li>
<li>Here is the code for the merge function:</li>
<li><pre><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title">merge</span>(<span class="hljs-params">ArrayList&lt;Integer&gt; a, ArrayList&lt;Integer&gt; b</span>)
</span>{
    ArrayList&lt;Integer&gt; c = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();

    <span class="hljs-keyword">while</span> (a.size() &gt; <span class="hljs-number">0</span> &amp;&amp; b.size() &gt; <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">if</span> (a.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>) &gt; b.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>))
        {
            c.<span class="hljs-keyword">add</span>(b.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>));
            b.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            c.<span class="hljs-keyword">add</span>(a.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>));
            a.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);
        }
    }

    <span class="hljs-keyword">while</span>(a.size() &gt; <span class="hljs-number">0</span>)
    {
        c.<span class="hljs-keyword">add</span>(a.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>));
        a.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">while</span>(b.size() &gt; <span class="hljs-number">0</span>)
    {
        c.<span class="hljs-keyword">add</span>(b.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>));
        b.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">return</span> c;
}
</code></pre></li>
<li>The time complexity of this sort is O(n * log n) in all cases.</li>
</ul>
<h2 id="-countingsort-https-github-com-mrjmac-sorts-blob-main-countingsort-java-"><a href="https://github.com/mrjmac/sorts/blob/main/countingsort.java">countingsort</a></h2>
<ul>
<li>A very mindblowing sort the first time you see it. However, it is extremely intuitive and ingenious.</li>
<li>Sorts numbers out of place, so two arrays are needed.</li>
<li>First, you count the number of times that each unique number in the array appears. In order to be able to do this, you have to know the maximum value in the array. The code for this can be seen here:</li>
<li><pre><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-keyword">sort</span>.length - <span class="hljs-number">1</span>; i++)
{
    <span class="hljs-keyword">count</span>[<span class="hljs-keyword">sort</span>[i]] += <span class="hljs-number">1</span>;
}
</code></pre></li>
<li>Next, you find the prefix sum of the array from the previous step.</li>
<li>If you think about it, this makes complete sense as the count of each unique number represents how many spaces they fill. In order for a two to fit in the array, it must consider how many spaces the ones take up.</li>
<li>The code for this process can be seen here:</li>
<li><pre><code>for (int <span class="hljs-keyword">j </span>= <span class="hljs-number">1</span><span class="hljs-comment">; j &lt;= max; j++)</span>
{
    <span class="hljs-built_in">count</span>[<span class="hljs-keyword">j] </span>+= <span class="hljs-built_in">count</span>[<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>]<span class="hljs-comment">;</span>
}
</code></pre></li>
<li>Finally, you loop through the original array backwards and check the index of the number in order to find where it belongs. You subtract 1 from this number as arrays start at 0 and not 1. You place the number in the spot that is returned.</li>
<li>The code for this can be seen here:</li>
<li><pre><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-keyword">sort</span>.length - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--)
{
    <span class="hljs-keyword">count</span>[<span class="hljs-keyword">sort</span>[k]] -= <span class="hljs-number">1</span>;
    output[<span class="hljs-keyword">count</span>[<span class="hljs-keyword">sort</span>[k]]] = <span class="hljs-keyword">sort</span>[k];
}
</code></pre></li>
<li>The time complexity of this is O(n + k), where k is equal to the range of values in the array. This is true for all cases.</li>
</ul>

<h2 id="-quicksort-https-github-com-mrjmac-sorts-blob-main-quicksort-java-"><a href="https://github.com/mrjmac/sorts/blob/main/quicksort.java">quicksort</a></h2>
<ul>
<li>A pretty simple recursive sort, much more simple than mergesort.</li>
<li>This gets a lot more complicated when you optimize your pivot location.</li>
<li>Picks a number and moves all numbers around that number so that the higher numbers are after it and the lower numbers are before it.</li>
<li>The code for that can be seen here: </li>
<li><pre><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span>
</span>{
    <span class="hljs-keyword">int</span> pivot = arr[high];
    <span class="hljs-keyword">int</span> greater = low - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt; high; i++)
    {
        <span class="hljs-keyword">if</span> (arr[i] &lt;= pivot)
        {
            greater += <span class="hljs-number">1</span>;
            swap(arr, greater, i);
        }
    }
    swap(arr, greater + <span class="hljs-number">1</span>, high);


    <span class="hljs-keyword">return</span> greater + <span class="hljs-number">1</span>;
}
</code></pre></li>
<li>Once this is done, the same is recursively called at the end of our driver function to pivot again around the values from 0 to our first pivot and our first pivot to the end.</li>
<li>Here&#39;s the driver code:</li>
<li>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">sort</span>(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)
{
    <span class="hljs-keyword">if</span> (low &lt; high)
    {
        <span class="hljs-keyword">int</span> pivot = partition(arr, low, high);
        <span class="hljs-keyword">sort</span>(arr, low, pivot - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">sort</span>(arr, pivot + <span class="hljs-number">1</span>, high);
    }
}
</code></pre></li>
<li>The time complexity of this sort is O(n^2) worse case and O(n* log n) in the average and best case.</li>
</ul>
<h2 id="-radixsort-https-github-com-mrjmac-sorts-blob-main-radixsort-java-"><a href="https://github.com/mrjmac/sorts/blob/main/radixsort.java">radixsort</a></h2>
<ul>
<li>This was invented by an incredibly intelligent man.</li>
<li>In order to save time on larger numbers compared to counting sort, runs a counting sort on each individual digit of every number. The code for a counting sort can be found <a href="https://github.com/mrjmac/sorts/blob/main/countingsort.java">here</a>.</li>
<li>Here&#39;s the code for this sort:</li>
<li>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>)
{
    <span class="hljs-built_in">int</span> <span class="hljs-built_in">max</span> = getMax(arr);
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-built_in">max</span> / i &gt; <span class="hljs-number">0</span>; i *= <span class="hljs-number">10</span>)
    {
        countingSort(arr, <span class="hljs-built_in">size</span>, i);
    }

}
</code></pre></li>
<li>The time complexity of this sort is O(d(n+k)) where K is the greatest number in the digits spot and d is the number of digits. I&#39;m not certain about this, but I&#39;m pretty sure.</li>
</ul>
<h2 id="-bogosort-https-github-com-mrjmac-sorts-blob-main-bogosort-cpp-"><a href="https://github.com/mrjmac/sorts/blob/main/bogosort.cpp">bogosort</a></h2>
<ul>
<li>This should not have been invented.</li>
<li>Randomly scrambles the elements in the array until they are sorted.</li>
<li>Worst case time complexity never finishes as you can't guarantee that the array will ever scramble correctly.</li>
<li>The main code loop:</li>
<li><pre><code><span class="hljs-keyword">while</span>(!sorted)
{
  random_shuffle(<span class="hljs-keyword">begin</span>(bogo), <span class="hljs-keyword">end</span>(bogo));
  <span class="hljs-keyword">if</span> (isSorted(bogo, size))
  {
      sorted = <span class="hljs-literal">true</span>;
  }
}
</code></pre></li>
</ul>




